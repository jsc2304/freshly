const { Low } = require('lowdb');
const { JSONFile } = require('lowdb/node');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const inventoryService = require('./inventoryService');

class ShoppingListService {
  constructor() {
    this.dbPath = path.join(__dirname, '..', 'data', 'shopping-list.json');
    this.adapter = new JSONFile(this.dbPath);
    this.db = new Low(this.adapter);
    this.initializeDb();
  }

  async initializeDb() {
    await this.db.read();
    this.db.data = this.db.data || { items: [], templates: [] };
    await this.db.write();
  }

  async getShoppingList() {
    await this.db.read();
    return this.db.data.items || [];
  }

  async addItem(itemData) {
    await this.db.read();
    
    const newItem = {
      id: uuidv4(),
      name: itemData.name,
      category: itemData.category || 'Other',
      quantity: itemData.quantity || 1,
      unit: itemData.unit || 'piece',
      priority: itemData.priority || 'medium',
      completed: false,
      addedDate: new Date().toISOString(),
      source: itemData.source || 'manual'
    };

    this.db.data.items.push(newItem);
    await this.db.write();
    
    return newItem;
  }

  async updateItem(id, updates) {
    await this.db.read();
    
    const itemIndex = this.db.data.items.findIndex(item => item.id === id);
    if (itemIndex === -1) {
      return null;
    }

    this.db.data.items[itemIndex] = {
      ...this.db.data.items[itemIndex],
      ...updates,
      updatedDate: new Date().toISOString()
    };

    await this.db.write();
    return this.db.data.items[itemIndex];
  }

  async deleteItem(id) {
    await this.db.read();
    
    const itemIndex = this.db.data.items.findIndex(item => item.id === id);
    if (itemIndex === -1) {
      return false;
    }

    this.db.data.items.splice(itemIndex, 1);
    await this.db.write();
    return true;
  }

  async generateShoppingList() {
    try {
      // Get current inventory
      const inventory = await inventoryService.getInventory();
      
      // Get items that are low in stock
      const lowStockItems = await inventoryService.getLowStockItems(2);
      
      // Get items expiring soon (negative logic - items we might want to replace)
      const expiringItems = await inventoryService.getExpiringItems(3);
      
      // Get essential items template
      const essentialItems = await this.getEssentialItemsTemplate();
      
      const generatedItems = [];
      
      // Add low stock items
      lowStockItems.forEach(item => {
        generatedItems.push({
          name: item.name,
          category: item.category,
          quantity: this.calculateNeededQuantity(item),
          unit: item.unit,
          priority: 'high',
          source: 'low_stock',
          reason: `Low stock (${item.quantity} ${item.unit} remaining)`
        });
      });
      
      // Add items based on essential template that are missing
      essentialItems.forEach(essential => {
        const inventoryItem = inventory.find(item => 
          item.name.toLowerCase().includes(essential.name.toLowerCase()) ||
          essential.name.toLowerCase().includes(item.name.toLowerCase())
        );
        
        if (!inventoryItem || inventoryItem.quantity < essential.minQuantity) {
          const existing = generatedItems.find(item => 
            item.name.toLowerCase() === essential.name.toLowerCase()
          );
          
          if (!existing) {
            generatedItems.push({
              name: essential.name,
              category: essential.category,
              quantity: essential.recommendedQuantity,
              unit: essential.unit,
              priority: essential.priority,
              source: 'essential_template',
              reason: inventoryItem ? 
                `Below minimum stock (${inventoryItem.quantity} < ${essential.minQuantity})` : 
                'Not in inventory'
            });
          }
        }
      });
      
      // Clear existing auto-generated items and add new ones
      await this.clearAutoGeneratedItems();
      
      const addedItems = [];
      for (const item of generatedItems) {
        const addedItem = await this.addItem(item);
        addedItems.push(addedItem);
      }
      
      return {
        generated: addedItems,
        summary: {
          total: addedItems.length,
          highPriority: addedItems.filter(item => item.priority === 'high').length,
          lowStock: addedItems.filter(item => item.source === 'low_stock').length,
          essential: addedItems.filter(item => item.source === 'essential_template').length
        }
      };
      
    } catch (error) {
      console.error('Error generating shopping list:', error);
      throw error;
    }
  }

  async clearAutoGeneratedItems() {
    await this.db.read();
    
    // Remove items that were auto-generated (not manually added)
    this.db.data.items = this.db.data.items.filter(item => 
      item.source === 'manual' || item.completed
    );
    
    await this.db.write();
  }

  calculateNeededQuantity(item) {
    // Simple logic: if quantity is 0, suggest 1; if quantity is 1, suggest 2, etc.
    const baseQuantity = Math.max(1, item.quantity);
    return Math.ceil(baseQuantity * 2);
  }

  async getEssentialItemsTemplate() {
    // This could be loaded from database or configuration
    return [
      { name: 'Milk', category: 'Dairy', minQuantity: 1, recommendedQuantity: 2, unit: 'l', priority: 'high' },
      { name: 'Bread', category: 'Grains', minQuantity: 1, recommendedQuantity: 2, unit: 'piece', priority: 'high' },
      { name: 'Eggs', category: 'Dairy', minQuantity: 6, recommendedQuantity: 12, unit: 'piece', priority: 'high' },
      { name: 'Butter', category: 'Dairy', minQuantity: 1, recommendedQuantity: 2, unit: 'piece', priority: 'medium' },
      { name: 'Bananas', category: 'Fruits', minQuantity: 3, recommendedQuantity: 6, unit: 'piece', priority: 'medium' },
      { name: 'Apples', category: 'Fruits', minQuantity: 3, recommendedQuantity: 6, unit: 'piece', priority: 'medium' },
      { name: 'Carrots', category: 'Vegetables', minQuantity: 500, recommendedQuantity: 1000, unit: 'g', priority: 'medium' },
      { name: 'Potatoes', category: 'Vegetables', minQuantity: 1, recommendedQuantity: 2, unit: 'kg', priority: 'medium' },
      { name: 'Tomatoes', category: 'Vegetables', minQuantity: 3, recommendedQuantity: 6, unit: 'piece', priority: 'medium' },
      { name: 'Chicken', category: 'Meat', minQuantity: 500, recommendedQuantity: 1000, unit: 'g', priority: 'low' },
      { name: 'Rice', category: 'Grains', minQuantity: 500, recommendedQuantity: 1000, unit: 'g', priority: 'low' },
      { name: 'Pasta', category: 'Grains', minQuantity: 500, recommendedQuantity: 1000, unit: 'g', priority: 'low' }
    ];
  }

  async getItemsByCategory() {
    const items = await this.getShoppingList();
    const categories = {};
    
    items.forEach(item => {
      if (!categories[item.category]) {
        categories[item.category] = [];
      }
      categories[item.category].push(item);
    });
    
    return categories;
  }

  async getCompletedItems() {
    const items = await this.getShoppingList();
    return items.filter(item => item.completed);
  }

  async getPendingItems() {
    const items = await this.getShoppingList();
    return items.filter(item => !item.completed);
  }

  async markItemCompleted(id) {
    return await this.updateItem(id, { completed: true });
  }

  async markItemPending(id) {
    return await this.updateItem(id, { completed: false });
  }

  async clearCompletedItems() {
    await this.db.read();
    
    this.db.data.items = this.db.data.items.filter(item => !item.completed);
    await this.db.write();
    
    return true;
  }
}

module.exports = new ShoppingListService();
